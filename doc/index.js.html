<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
/**
 * @file startline main
 * @module startline
 * @package startline
 * @subpackage main
 * @version 1.3.7
 * @author hex7c0 &lt;hex7c0@gmail.com>
 * @copyright hex7c0 2014
 * @license GPLv3
 */

/*
 * initialize module
 */
var fs = require('fs');
var readline = require('readline');
var event = require('events').EventEmitter;
var inherits = require('util').inherits;
var eol = require('os').EOL;

/*
 * functions
 */
/**
 * build stream interface
 * 
 * @function interfac
 * @param {Object} options - various options. Check README.md
 * @param {Integer} start - starting bytes
 * @param {Integer} [end] - ending bytes
 * @return {Objetc}
 */
function interfac(options, start, end) {

    var go;
    if (end >= 0) {
        go = fs.createReadStream(options.file, {
            flags: options.flag,
            mode: options.mode,
            encoding: options.encoding,
            autoClose: options.autoClose,
            start: start,
            end: end,
            fd: null,
        });
    } else {
        go = fs.createReadStream(options.file, {
            flags: options.flag,
            mode: options.mode,
            encoding: options.encoding,
            autoClose: options.autoClose,
            start: start,
            fd: null,
        });
    }
    return go;
}

/**
 * build readline interface
 * 
 * @function readlin
 * @param {Object} options - various options. Check README.md
 * @param {Integer} start - starting bytes
 * @param {Integer} [end] - ending bytes
 * @return {Objetc}
 */
function readlin(options, start, end) {

    var go;
    go = readline.createInterface({
        input: interfac(options, start, end),
        output: null,
        terminal: false,
    });
    return go;
}

/**
 * export class
 * 
 * @exports startline
 * @function startline
 * @param {Object} options - various options. Check README.md
 * @return {STARTLINE}
 */
module.exports = function startline(options) {

    var options = options || Object.create(null);

    // file
    if (Boolean(options.file)) {
        var file = require('path').resolve(String(options.file));
        if (!fs.existsSync(file)) {
            var err = file + ' not exists';
            throw new Error(err);
        }
    } else {
        var err = '"file" is required';
        throw new Error(err);
    }

    // clean
    var my = {
        file: file,
        encoding: options.encoding,
        flag: String(options.flag || 'r'),
        mode: Number(options.mode) || 444,
        autoClose: options.autoClose == false ? false : true,
        start: Number(options.start) || 0,
        end: Number(options.end),
        rc4: options.rc4,
        autokey: options.autokey,
        lodash: Boolean(options.autokey),
    };

    return new STARTLINE(my);
};

/*
 * class
 */
/**
 * STARTLINE class
 * 
 * @class STARTLINE
 * @param {Object} options - various options. Check README.md
 */
function STARTLINE(options) {

    event.call(this);
    var self = this; // closure
    var temp = '';
    this.options = options;
    this.head = 0;
    this.tail = 0;
    this.line = 0;
    this._stream;

    if (options.rc4 || options.autokey) {
        var cipher;
        this._stream = interfac(this.options, options.start, options.end);
        if (options.rc4) {
            cipher = require('arc4')(String(options.rc4), options.lodash);
            this._stream.on('data', function(callback) {

                var callback = cipher.decodeBuffer(callback).toString();
                for (var i = 0, ii = callback.length; i &lt; ii; i++) {
                    if (callback[i] === eol) {
                        self.tail = self.head + self.line;
                        self.head = self.tail + temp.length;
                        self.emit('line', temp);
                        self.line = 1;
                        temp = '';
                    } else {
                        temp += callback[i];
                    }
                }
                if (temp.length > 0) {
                    self.tail = self.head + self.line;
                    self.head = self.tail + temp.length;
                    self.emit('line', temp);
                    self.line = 1;
                }
                return;
            });
        } else {
            cipher = require('autokey')
                    (String(options.autokey), options.lodash);
            this._stream.on('data', function(callback) {

                var callback = cipher.decodeBuffer(callback).toString();
                for (var i = 0, ii = callback.length; i &lt; ii; i++) {
                    if (callback[i] === eol) {
                        self.tail = self.head + self.line;
                        self.head = self.tail + temp.length;
                        self.emit('line', temp);
                        self.line = 1;
                        temp = '';
                    } else {
                        temp += callback[i];
                    }
                }
                if (temp.length > 0) {
                    self.tail = self.head + self.line;
                    self.head = self.tail + temp.length;
                    self.emit('line', temp);
                    self.line = 1;
                }
                return;
            });
        }
    } else if (options.end >= 0) {
        this._stream = interfac(this.options, options.start, options.end);
        this._stream.on('data', function(callback) {

            var callback = callback.toString();
            for (var i = 0, ii = callback.length; i &lt; ii; i++) {
                if (callback[i] === eol) {
                    self.tail = self.head + self.line;
                    self.head = self.tail + temp.length;
                    self.emit('line', temp);
                    self.line = 1;
                    temp = '';
                } else {
                    temp += callback[i];
                }
            }
            if (temp.length > 0) {
                self.tail = self.head + self.line;
                self.head = self.tail + temp.length;
                self.emit('line', temp);
                self.line = 1;
            }
            return;
        });
    } else {
        this._stream = readlin(this.options, options.start, options.end);
        this._stream.on('line', function(callback) {

            self.tail = self.head + self.line;
            self.head = self.tail + callback.length;
            self.emit('line', callback);
            self.line = 1;
            return;
        });
    }
    this._stream.on('pause', function() {

        self.emit('pause');
        return;
    });
    this._stream.on('resume', function() {

        self.emit('resume');
        return;
    });
    this._stream.on('open', function(fd) {

        self.emit('open', fd);
        return;
    });
    this._stream.on('close', function() {

        self.emit('close');
        return;
    });
    this._stream.on('end', function() {

        self.emit('end');
        return;
    });
    this._stream.on('error', function(err) {

        self.emit('error', err);
        return;
    });
}
inherits(STARTLINE, event);
/**
 * _stream pause
 * 
 * @function pause
 */
STARTLINE.prototype.pause = function() {

    this._stream.pause();
    return;
};
/**
 * _stream resume
 * 
 * @function resume
 */
STARTLINE.prototype.resume = function() {

    this._stream.resume();
    return;
};
/**
 * read file with different limit
 * 
 * @function read
 * @param {Integer} start - starting bytes
 * @param {Integer} [end] - ending bytes
 * @return {STARTLINE}
 */
STARTLINE.prototype.read = function(start, end) {

    var my = this.options;
    my.start = Number(start) || 0;
    my.end = Number(end);
    return new STARTLINE(my);
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-startline.html">startline</a></li></ul><h3>Classes</h3><ul><li><a href="module-startline-STARTLINE.html">STARTLINE</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a> on Sun Sep 07 2014 09:22:05 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
